package tw.jruletest.parse.ruletree;

import tw.jruletest.exceptions.InvalidRuleStructureException;
import tw.jruletest.parse.ruletree.argumentnodes.*;
import tw.jruletest.parse.ruletree.expressionnodes.*;
import tw.jruletest.parse.ruletree.rulenodes.*;

/**
 * Interface for the expected implementation of nodes to be added to a tree in order to validate rules and generate the required code.
 *
 * @author Toby Wride
 * */

public abstract class TreeNode {

    protected int endIndex = 0;

    public static final int RETURN_VALUE_NODE = 1;
    public static final int ARGUMENT_NODE = 2;
    public static final int EXPRESSION_NODE = 3;

    // Use until complex arguments implemented
    public static final int BASIC_ARGUMENT_NODE = 4;

    /**
     * Generate code based on child nodes' code generation and any extra syntax required for the code to compile.
     *
     * @return the code generated by the node.
     * */

    public abstract String generateCode();

    /**
     * Validates the structure of the rule based on expected structures and validity of the rule determined by the required child nodes
     *
     * @param ruleContent rule segment to be validated
     *
     * @return the index required to extract the valid segment from the rule
     *
     * @throws InvalidRuleStructureException thrown if the rule is not found to be valid.
     * */

    public abstract void validateRule(String ruleContent) throws InvalidRuleStructureException;

    /**
     * Gets the index where the validity of the rule ends
     *
     * @return the index of the last valid character
     * */

    public int getEndIndex() {
        return endIndex;
    }

    public static TreeNode getChildNode(String ruleContent, int possibleNodeIndex) throws InvalidRuleStructureException {
        TreeNode[] possibleNodes = {};
        switch(possibleNodeIndex) {
            case RETURN_VALUE_NODE:
                possibleNodes = new TreeNode[] {new MethodNode(), new FieldNode(), new VariableNode()};
                break;
            case ARGUMENT_NODE:
                possibleNodes = new TreeNode[] {new ValueNode(), new StringNode(), new ConstantNode(), new VariableNode()};
                break;
            case EXPRESSION_NODE:
                possibleNodes = new TreeNode[] {new MathematicalExpressionNode(), new BooleanExpressionNode(), new NumericalExpressionNode()};
                break;
            case BASIC_ARGUMENT_NODE:
                possibleNodes = new TreeNode[] {new StringNode(), new ConstantNode(), new VariableNode()};
                break;
        }

        for(TreeNode possibleNode: possibleNodes) {
            try {
                possibleNode.validateRule(ruleContent);
                return possibleNode;
            } catch(InvalidRuleStructureException e) { }
        }
        throw new InvalidRuleStructureException(ruleContent, "Child Node Selector");
    }
}
