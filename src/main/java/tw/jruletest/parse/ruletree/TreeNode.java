package tw.jruletest.parse.ruletree;

import tw.jruletest.exceptions.InvalidRuleStructureException;
import tw.jruletest.parse.ruletree.argumentnodes.*;
import tw.jruletest.parse.ruletree.expressionnodes.*;
import tw.jruletest.parse.ruletree.rulenodes.*;

/**
 * Interface for the expected implementation of nodes to be added to a tree in order to validate rules and generate the required code.
 *
 * @author Toby Wride
 * */

public abstract class TreeNode {

    protected int endIndex = 0;

    public static final int CHILD_NODE = 1;
    public static final int VALUE_RETRIEVAL_NODE = 2;
    public static final int BOOLEAN_EXPRESSION_NODE = 3;
    public static final int OPERABLE_NODE = 4;

    /**
     * Generate code based on child nodes' code generation and any extra syntax required for the code to compile.
     *
     * @return the code generated by the node.
     * */

    public abstract String generateCode();

    /**
     * Validates the structure of the rule based on expected structures and validity of the rule determined by the required child nodes
     *
     * @param ruleContent rule segment to be validated
     *
     * @return the index required to extract the valid segment from the rule
     *
     * @throws InvalidRuleStructureException thrown if the rule is not found to be valid.
     * */

    public abstract void validateRule(String ruleContent) throws InvalidRuleStructureException;

    /**
     * Gets the index where the validity of the rule ends
     *
     * @return the index of the last valid character
     * */

    public int getEndIndex() {
        return endIndex;
    }

    public static TreeNode getChildNode(String ruleContent, int possibleNodeIndex) throws InvalidRuleStructureException {
        TreeNode[] possibleNodes = {};
        switch(possibleNodeIndex) {
            case CHILD_NODE:
                possibleNodes = new TreeNode[] {new NegatedExpressionNode(), new BinaryBooleanExpressionNode(),
                                                new LogicalComparisonNode(), new MathematicalExpressionNode(), new ValueNode(),
                                                new StringNode(), new ConstantNode()};
                break;
            case VALUE_RETRIEVAL_NODE:
                possibleNodes = new TreeNode[] {new MethodNode(), new FieldNode(), new VariableNode()};
                break;
            case BOOLEAN_EXPRESSION_NODE:
                possibleNodes = new TreeNode[] { new BinaryBooleanExpressionNode(), new NegatedExpressionNode(), new LogicalComparisonNode(),
                                                new ValueNode(), new ConstantNode()};
                break;
            case OPERABLE_NODE:
                possibleNodes = new TreeNode[] {new MathematicalExpressionNode(), new ValueNode(), new StringNode(), new ConstantNode()};
                break;
        }

        for(TreeNode possibleNode: possibleNodes) {
            try {
                possibleNode.validateRule(ruleContent);
                return possibleNode;
            } catch(InvalidRuleStructureException e) { }
        }
        throw new InvalidRuleStructureException(ruleContent, "Child Node Selector");
    }
}
